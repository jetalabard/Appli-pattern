insert into About values(0,"J'ai eu envie de faire cette application dans le but de me perfectionner en Android mais aussi pour me remémorer les différents patrons de conception du Gang of Four","Je me suis inspirer d'un site internet :","www.goprod.bouhours.net","www.facebook.com/jeremy.talabard","Mon site internet","talabard-jeremy.fr.cr");
insert into Pattern values(0,"Adaptateur","adapteur.png");
insert into Pattern values(1,"Chaîne de responsabilité","chaine_responsabilite.png");
insert into Pattern values(2,"Commande","commande.png");
insert into Pattern values(3,"Composite","composite.png");
insert into Pattern values(4,"Décorateur","decorateur.png");
insert into Pattern values(5,"Etat","etat.png");
insert into Pattern values(6,"Fabrique abstraite","fabrique_abstraite.png");
insert into Pattern values(7,"Fabrique Simple","fabrique_simple.png");
insert into Pattern values(8,"Façade","facade.png");
insert into Pattern values(9,"Interprète","interprete.png");
insert into Pattern values(10,"Itérateur","iterateur.png");
insert into Pattern values(11,"Mediateur","mediateur.png");
insert into Pattern values(12,"Memento","memento.png");
insert into Pattern values(13,"Monteur","monteur.png");
insert into Pattern values(14,"Observateur","observateur.png");
insert into Pattern values(15,"Patron de Méthode","patron_methode.png");
insert into Pattern values(16,"Poids-Mouche","poids_mouche.png");
insert into Pattern values(17,"Pont","pont.png");
insert into Pattern values(18,"Procuration","procuration.png");
insert into Pattern values(19,"Prototype","prototype.png");
insert into Pattern values(20,"Singleton","singleton.png");
insert into Pattern values(21,"Stratégie","strategie.png");
insert into Pattern values(22,"Visiteur","visiteur.png");
insert into Description values(0,"Structurel","Convertit l'interface d'une classe en une autre conformément à l'attente du client. L'Adaptateur permet à des classes de collaborer, alors qu'elles n'auraient pas pu le faire du fait d'interfaces incompatibles.",0);
insert into Description values(1,"Comportemental","Évite le couplage de l'émetteur d'une requête avec ses récepteurs, en donnant à plus d'un objet la possibilité d'entreprendre la requête.Chaîne les objets récepteurs et fait passer la requête tout au long de la chaîne, jusqu'à ce qu'un objet la traite.",1);
insert into Description values(2,"Comportemental","Encapsule une requête comme un objet, autorisant ainsi le paramétrage des clients par différentes requêtes, files d’attente et récapitulatifs de requêtes, et de plus, permettant la réversion des opérations.",2);
insert into Description values(3,"Structurel","Compose des objets en des structures arborescentes pour représenter des hiérarchies composant/composé.Permet au client de traiter d’une unique façon les objets et les combinaisons d’objets.",3);
insert into Description values(4,"Structurel","Attache dynamiquement des responsabilités supplémentaires à un objet. Les décorateurs fournissent une alternative souple à la dérivation, pour étendre les fonctionnalités.",4);
insert into Description values(5,"Comportemental","Permet à un objet de modifier son comportement, quand son état interne change. Tout se passe comme si l'objet changeait de classe.",5);
insert into Description values(6,"Créateur","Fournit une interface pour la création de familles d'objets apparentés ou interdépendants, sans qu'il soit nécessaire de spécifier leurs classes concrètes.",6);
insert into Description values(7,"Créateur","Définit une interface pour la création d'un objet, mais en laissant à des sous-classes le choix des classes à instancier. La Fabrique simple permet à une classe de déléguer l'instanciation à des sous-classes.",7);
insert into Description values(8,"Structurel","Fournit une interface unifiée, à l'ensemble des interfaces d'un sous-système. La Façade fournit une interface de plus haut niveau, qui rend le sous-système plus facile à utiliser.",8);
insert into Description values(9,"Comportemental","Pour un langage donné, définit une représentation de sa grammaire, en même temps qu'un interprète utilisant cette représentation interprète les phrases du langage.",9);
insert into Description values(10,"Comportemental","Fournit un moyen d'accès séquentiel aux éléments d'un agrégat d'objets, sans mettre à découvert la représentation interne de celui-ci",10);
insert into Description values(11,"Comportemental","Définit un objet qui encapsule les modalités d'interaction d'un certain ensemble d'objets. La médiateur favorise le couplage faible en dispensant les objets de se faire explicitement référence, et il permet donc de faire varier indépendamment les relations d’interaction.",11);
insert into Description values(12,"Comportemental","Sans violer l'encapsulation, le Mémento permet de saisir et de transmettre à l'extérieur d'un objet l'état interne de celui-ci, dans le but de pouvoir ultérieurement le restaurer dans cet état.",12);
insert into Description values(13,"Créateur","Dissocie la construction d'un objet complexe de sa représentation, de sorte que le même processus de construction permette des représentations différentes.",13);
insert into Description values(14,"Comportemental","Définit une interdépendance de type un à plusieurs, de telle façon que quand un objet change d'état, tous ceux qui en dépendant en soient notifiés et automatiquement mis à jour.",14);
insert into Description values(15,"Comportemental","Définit, dans une opération, le squelette d'un algorithme, en en déléguant certaines étapes à des sous-classes. Le Patron de méthode permet de redéfinir par des sous-classes, certaines parties d'un algorithme, sans avoir à modifier la structure de ce dernier.",15);
insert into Description values(16,"Structurel","Utilise une technique de partage qui permet la mise en oeuvre efficace d'un grand nombre d'objets de fine granularité.",16);
insert into Description values(17,"Structurel","Découple une abstraction de son implémentation afin que les deux éléments puissent être modifiés indépendamment l'un de l'autre.",17);
insert into Description values(18,"Structurel","Fournit à un tiers un mandataire ou un remplaçant, pour contrôler l'accès à cet objet.",18);
insert into Description values(19,"Créateur","Spécifie le type des objets à créer à partir d'une instance de prototype, et crée de nouveaux objets en copiant ce prototype.",19);
insert into Description values(20,"Créateur","Garantir qu'une classe n'a qu'une seule instance et fournir un point d'accès de type global à cette classe.",20);
insert into Description values(21,"Comportemental","Définit une famille d'algorithmes, encapsule chacun d'entre eux et les rend interchangeables. Le Stratégie permet aux algorithmes d'évoluer indépendamment des clients qui les utilisent.",21);
insert into Description values(22,"Comportemental","Fait la représentation d'une opération applicable aux éléments d'une structure d'objet. Il définit une nouvelle opération, sans qu'il soit nécessaire de modifier la classe des éléments sur lesquels elle agit.",22);
insert into Applicability values(0,"Vous voulez utiliser une classe existante, mais dont l'interface ne coïncide pas avec celle escomptée.",0);
insert into Applicability values(1,"Vous souhaitez créer une classe réutilisable qui collabore avec des classes sans relations avec elle et encore inconnues, c'est-à-dire avec des classes qui n'auront pas nécessairement des interfaces compatibles.",0);
insert into Applicability values(2,"(pour le cas adaptateur d'objet seulement) vous avez besoin d'utiliser plusieurs sous-classes existantes, mais l'adaptation de leur interface par dérivation de chacune d'entre elles est impraticable. Un adaptateur objet peut adapter l'interface de sa classe parente.",0);
insert into Applicability values(3,"Une requête peut être gérée par plus d'un objet à la fois, et que le gestionnaire n'est pas connu a priori. Ce dernier doit être déterminé automatiquement.",1);
insert into Applicability values(4,"Vous souhaitez adresser une requête à un ou plusieurs objets, sans spécifier explicitement le récepteur.",1);
insert into Applicability values(5,"L'ensemble des objets qui peuvent traiter une requête doit être défini dynamiquement.",1);
insert into Applicability values(6,"Introduire dans des objets, sous la forme de paramètres, des actions à effectuer. Un tel paramétrage peut s'exprimer en langage procédural par l'intermédiaire de fonctions callback, c'est-à-dire, des fonctions enregistrées dans un certain contexte pour être appelées ultérieurement. Les commandes sont la version orientée objet des fonctions callbacks.",2);
insert into Applicability values(7,"Spécifier, mettre en file d'attente, et exécuter les requêtes à différents instants. Un objet Commande peut avoir une durée de vie indépendante de la requête originale. Si le récepteur d'une requête peut avoir une représentation indépendante de l'espace adresse, alors on peut transférer l'objet Commande pour la requête à un autre processus et y servir complètement la requête.",2);
insert into Applicability values(8,"Assurer des Undo. L'opération Execute de Commande peut stocker un état pour inverser son effet dans la commande elle-même. L'interface de Commande doit posséder une opération supplémentaire, Undo, qui supprime les effets d'un précédent appel à Execute. Les commandes exécutées sont stockées dans une liste historique. Un nombre indéterminé d'opérations Redo et Undo peuvent s'effectuer par la traversée de cette liste de façon rétrograde ou directe, par appels de Undo et Execute respectivement.",2);
insert into Applicability values(9,"Permettre une mémorisation de modifications, afin de pouvoir les appliquer à nouveau après un éventuel crash système. En ajoutant à l'interface de Commande les opérations charger et stocker, on peut réaliser un enregistrement persistant des modifications. Récupérer d'un crash, implique de recharger les commandes enregistrées depuis le disque et de les exécuter à nouveau à l'aide de l'opération Exécute.",2);
insert into Applicability values(10,"Structurer un système autour d'opérations de haut niveau, construites à l'aide de primitives. Une structure de ce type est courante dans les systèmes d'information qui autorisent les transactions. Une transaction encapsule un ensemble de modifications à effectuer sur des données. La commande fournit le moyen de modéliser les transactions. Les commandes ont une interface commune qui permet d'invoquer toutes les transactions de la même manière. Le modèle favorise également l'extension du système par l'apport de nouvelles transactions.",2);
insert into Applicability values(11,"Vous souhaitez représenter des hiérarchies de l'individu.",3);
insert into Applicability values(12,"Vous souhaitez que le client n'ait pas à se préoccuper de la différence entre 'combinaisons d'objets' et 'objets individuels'. Les clients pourront traiter de façon uniforme tous les objets de la structure composite.",3);
insert into Applicability values(13,"Pour ajouter dynamiquement des responsabilités à des objets individuels, ceci d'une façon transparente, c'est-à-dire, sans affecter les autres objets.",4);
insert into Applicability values(14,"Pour des responsabilités qui doivent pouvoir être retirées.",4);
insert into Applicability values(15,"Quand l'extension par dérivation est impraticable. Il peut arriver parfois que l'on ait un grand nombre d'extensions indépendantes possibles ; il en résulte une prolifération explosive de sous-classes pour permettre chaque combinaison. D'autres fois, la définition de classe pourra être cachée, ou encore inaccessible pour la dérivation.",4);
insert into Applicability values(16,"Le comportement d'un objet dépend de son état, et son comportement doit changer dynamiquement, en fonction de cet état.",5);
insert into Applicability values(17,"Les opérations comportent de grands pans entiers de déclarations conditionnelles fonctions de l'état de l'objet. Cet état est généralement désigné par une ou plusieurs constantes d'énumération. Souvent, plusieurs opérations différentes, contiendront la même structure conditionnelle. L'Etat place dans une classe séparée, chacune des branches de la condition. Ceci permet de traiter l'état de l'objet, comme un objet à part entière, qui peut varier indépendamment des autres objets.",5);
insert into Applicability values(18,"Un système doit être indépendant de la façon dont ses produits ont été créés, combinés, et représentés.",6);
insert into Applicability values(19,"Un système doit être constitué à partir d'une famille de produits, parmi plusieurs.",6);
insert into Applicability values(20,"On souhaite renforcer le caractère communautaire d'une famille d'objets conçus pour être utilisés ensemble.",6);
insert into Applicability values(21,"On souhaite fabriquer une bibliothèque de classes, en n'en révélant que l'interface et non l'implémentation.",6);
insert into Applicability values(22,"Une classe ne peut prévoir la classe des objets qu'elle aura à créer.",7);
insert into Applicability values(23,"Une classe attend de ses sous-classes qu'elles spécifient les objets qu'elles créent.",7);
insert into Applicability values(24,"Les classes délèguent des responsabilités à une de leurs nombreuses sous-classes assistantes, et que l'on veut disposer localement de l'information permettant de connaître la sous-classe assistante qui a reçu cette délégation.",7);
insert into Applicability values(25,"Vous souhaitez disposer d'une interface simple pour un sous-système complexe. Les sous-systèmes deviennent souvent plus complexes au fur et à mesure de leur évolution. La plupart des modèles, lorsqu'ils sont employés, engendrent des classes plus nombreuses et plus petites. Ceci rend le sous-système plus réutilisable et plus facile à personnaliser, mais il devient aussi plus difficile à employer pour les classes qui n'ont pas besoin de personnalisation. Une façade propose une simple vue par défaut du sous-système, qui est suffisante pour la plupart des clients. Seuls les clients demandant plus de spécificité devront regarder derrière la façade.",8);
insert into Applicability values(26,"Il y a beaucoup de relations de dépendance entre les clients et les classes d'implémentation d'une abstraction. On introduira une façade pour découpler le sous-système des clients et des autres sous-systèmes, favorisant ainsi l'indépendance et la portabilité du sous-système.",8);
insert into Applicability values(27,"Vous cherchez à structurer en niveaux un sous-système. On utilisera la façade pour définir un point d'entrée à chaque niveau du sous-système. Si des sous-système sont interdépendants, vous pouvez simplifier les relations entre eux en les faisant communiquer l'un avec l'autre, uniquement à travers leurs façades.",8);
insert into Applicability values(28,"Il faut utiliser l'Interprète, lorsqu'il y a un langage à interpréter, et que vous pouvez représenter les déclarations du langage sous forme d'arbres syntaxiques abstraits.",9);
insert into Applicability values(29,"La grammaire est simple. Pour les grammaires complexes, la hiérarchie de classes grammaire devient grande et impossible à gérer. Dans de tels cas des outils tels que les générateurs syntaxiques sont de meilleures solutions. Il peuvent interpréter des expressions sans construire d'arbres syntaxiques abstraits, ce qui permet d'économiser de la place et probablement du temps.",9);
insert into Applicability values(30,"L'efficacité n'est pas un souci majeur. Les Interprètes les plus efficaces ne sont pas généralement implémentés de façon à faire l'interprétation directe d'arbres syntaxiques, mais plutôt pour les traduire préalablement sous une autre forme. Par exemple, les expressions régulières sont fréquemment transformées en machines d'état. Mais même dans ce cas, le traducteur peut être implémenté avec l'Interprète, qui reste donc toujours applicable.",9);
insert into Applicability values(31,"Pour accéder au contenu d'un objet d'un agrégat sans en révéler la représentation interne",10);
insert into Applicability values(32,"Pour gérer simultanément plusieurs parcours dans des agrégats d'objets",10);
insert into Applicability values(33,"Pour offrir une interface uniforme pour les parcours au travers de diverses structures agrégats (c'est-à-dire, pour permettre l'itération polymorphe).",10);
insert into Applicability values(34,"Les objets d'un ensemble communiquent d'une façon bien définie mais très complexe et que le résultat des interdépendances est non structuré et difficile à appréhender.",11);
insert into Applicability values(35,"La réutilisation d'un objet est difficile, du fait qu'il fait référence à beaucoup d'autres objets et communique avec eux.",11);
insert into Applicability values(36,"Un comportement distribué entre plusieurs classes doit pouvoir être spécialisé sans une pléthore de dérivations.",11);
insert into Applicability values(37,"Un instantané de tout ou partie de l'état d'un objet, doit être sauvegardé de façon à pouvoir restaurer ultérieurement celui-ci, dans cet état",12);
insert into Applicability values(38,"L'utilisation d'une interface directe pour atteindre l'état, conduirait à révéler des détails de l'implémentation et à rompre l'encapsulation.",12);
insert into Applicability values(39,"L'algorithme de création d'un objet complexe doit être indépendant des parties qui composent l'objet et de la manière dont ces parties sont agencées",13);
insert into Applicability values(40,"Le processus de construction doit autoriser des représentations différentes de l'objet en construction.",13);
insert into Applicability values(41,"Quand un concept a deux représentations, l'une dépendant de l'autre. Encapsuler ces deux représentations dans des objets distincts permet de les réutiliser et de les modifier indépendamment.",14);
insert into Applicability values(42,"Quand la modification d'un objet nécessite de modifier les autres, et que l'on ne sait pas combien sont ces autres.",14);
insert into Applicability values(43,"Quand un objet doit être capable de faire une notification à d'autres objets sans faire d'hypothèses sur la nature de ces objets. En d'autres termes, quand ces objets ne doivent pas être trop fortement couplés.",14);
insert into Applicability values(44,"Implémenter une fois pour toutes les parties invariantes d'un algorithme, et laisser aux sous-classes le soin d'implémenter les parties dont le comportement est conçu comme modifiable.",15);
insert into Applicability values(45," Lorsqu'il faut, pour éviter la duplication de code, isoler le facteur commun des comportements de sous-classes, et l'implémenter dans une classe commune. C'est un bon exemple de la technique de la « décomposition pour généralisation », telle que décrite par Opdyke et Johnson (« refactoring to generalize »). On identifie d'abord les différences dans le code existant, et on répartit ces différences dans de nouvelles opérations. Enfin, on remplace le code modifiable par un patron de méthodes, qui appelle celles des nouvelles opérations qui conviennent.",15);
insert into Applicability values(46,"Pour le contrôle des extensions de sous-classes. On peut définir un Patron de méthodes qui présente en certains points spécifiques, des opérations socle, permettant ainsi des extensions à partir de ces seuls points.",15);
insert into Applicability values(47,"L'application utilise un grand nombre d'objets.",16);
insert into Applicability values(48,"Les coûts de stockage sont élevés du fait d'une réelle quantité d'objets.",16);
insert into Applicability values(49,"La plupart des états de l'objet peuvent être considérés comme extrinsèques.",16);
insert into Applicability values(50,"Plusieurs groupes d'objets peuvent être remplacés par un nombre relativement faible d'objets partagés, après que les états extrinsèques aient été retirés.",16);
insert into Applicability values(51,"L'application ne dépend pas de l'identité des objets. Du fait que les objets poids-mouche peuvent être partagés, des objets de conception distincts peuvent passer pour identiques lors de tests comparatifs.",16);
insert into Applicability values(52,"Vous souhaitez éviter un lien définitif entre une abstraction et son implémentation. Ce peut être le cas, par exemple, lorsque l'implémentation doit être choisie parmi plusieurs ou échangée avec une autre lors de l'exécution.",17);
insert into Applicability values(53,"Il faut que les abstractions et leurs implémentations puissent toutes deux être étendues par dérivation. Dans ce cas, le modèle du Pont permet de combiner les différentes abstractions et implémentations, et de les étendre indépendamment.",17);
insert into Applicability values(54,"Il ne faut pas que les modifications apportées à l'implémentation d'une abstraction aient un impact sur le code client (il ne doit pas avoir à être recompilé).",17);
insert into Applicability values(55,"(C++) Vous souhaitez cacher complètement au client, l'implémentation d'une abstraction. En C++, en effet, la représentation de la classe est visible dans l'interface de la classe.",17);
insert into Applicability values(56,"Vous êtes confrontés à une prolifération de classes. Ce type de hiérarchie de classes est typique des cas où il est nécessaire d'éclater un objet en deux parties. Rumbaugh utilise le terme de « généralisation imbriquée » (nested generalization), pour faire référence à de telles hiérarchies de classes.",17);
insert into Applicability values(57,"Vous voulez faire partager une même implémentation à plusieurs objets (en utilisant éventuellement un comptage des références), et que cela doive être caché au client. Un exemple simple est la classe String de Coplien, dans laquelle plusieurs objets peuvent partager la même représentation de chaîne de caractères (StringRep).",17);
insert into Applicability values(58,"L'utilisation de la Procuration est indiquée quand on a besoin de références à un objet, qui soient plus créatives et plus sophistiquées qu'un simple pointeur. Suivent quelques situations courantes dans lesquelles la Procuration peut être employée. 1. Une 'procuration à distance' fournit un représentant local d'un objet situé dans un espace adresse différent. Coplien baptise ce type de procuration, un « Ambassadeur ». 2. Une 'procuration virtuelle' crée des objets lourds à la demande. 3. Une 'procuration de protection' contrôle l'accès à l'objet original. Les procurations de protection sont utiles quand les objets doivent satisfaire différents droits d'accès. 4. Une 'référence intelligente' est le remplaçant d'un pointeur brut, qui réalise des opérations supplémentaires, lors de l'accès à l'objet.",18);
insert into Applicability values(59,"Décompte du nombre des références faites à un objet réel, de sorte que celui-ci puisse être libéré automatiquement, dés qu'il n'y a plus de références",18);
insert into Applicability values(60,"Charger en mémoire un objet persistant quand il est référencé pour la première fois",18);
insert into Applicability values(61,"Vérifier, avant d'y accéder, que l'objet réel est verrouillé, pour être sûr qu'aucun autre objet ne pourra le changer.",18);
insert into Applicability values(62,"Utilisez le Prototype lorsqu'un système doit être indépendant de la manière dont ses produits sont créés, composés et représentés",19);
insert into Applicability values(63,"Si les classes à instancier sont spécifiées à l'exécution, par exemple, par chargement dynamique",19);
insert into Applicability values(64,"Pour éviter de construire une hiérarchie de classes de fabriques, qui réplique la hiérarchie de classes de produits",19);
insert into Applicability values(65,"Si les instances d'une classe peuvent prendre un état parmi un petit nombre de combinaisons. Il peut être plus approprié d'installer le nombre requis de prototypes et d'en faire des clones, plutôt que d'instancier chaque fois la classe manuellement avec l'état correspondant.",18);
insert into Applicability values(66,"S'il doit n'y avoir exactement qu'une instance d'une classe, qui, de plus, doit être accessible aux clients en un point bien déterminé.",20);
insert into Applicability values(67,"Si l'instance unique doit être extensible par dérivation en sous-classe, et si l'utilisation d'une instance étendue doit être permise aux clients, sans qu'ils aient à modifier leur code.",20);
insert into Applicability values(68,"Plusieurs classes apparentées ne diffèrent que par leur comportement. Les Stratégies donnent le moyen d'appareiller une classe avec un comportement parmi plusieurs autres.",21);
insert into Applicability values(69,"On a besoin de diverses variantes d'un algorithme. Par exemple, on peut définir des algorithmes représentants différents compromis encombrement mémoire / temps d'exécution. Les Stratégies peuvent être utilisées quand ces variantes sont implémentées sous la forme d'une hiérarchie de classe d'algorithmes.",21);
insert into Applicability values(70,"Un algorithme utilise des données que les clients n'ont pas à connaître. Utiliser la Stratégie dispense d'avoir à révéler des structures complexes de données spécifiques des algorithmes.",21);
insert into Applicability values(71,"Une classe définit de nombreux comportements, qui figurent dans ses opérations sous la forme de déclarations conditionnelles multiples. Plutôt que laisser subsister ces expressions conditionnelles, on déplacera les sections correspondantes aux différentes branches, dans des classes Strategie qui leurs sont propres.",21);
insert into Applicability values(72,"Une structure d'objets contient beaucoup de classes différentes d'interfaces distinctes, et vous désirez réaliser des opérations sur ces objets qui dépendent de leurs classes concrètes.",22);
insert into Applicability values(73,"Il s'agit d'effectuer plusieurs opérations distinctes et sans relation entre elles, sur les objets d'une structure, et ceci en évitant de polluer leurs classes avec ces opérations. Le Visiteur permet de grouper toutes les opérations du même type dans une seule classe. Quand la structure est partagée par plusieurs applications, on utilisera le Visiteur pour placer les opérations dans celles des applications, qui seules en ont besoin.",22);
insert into Applicability values(74,"Les classes qui définissent la structure objet changent rarement, mais on doit souvent définir de nouvelles opérations sur cette structure. Modifier les classes de la structure impose de redéfinir l'interface avec tous les visiteurs, ce qui peut être coûteux. Si les classes de la structure d'objets changent souvent, il est sans doute préférable de définir les opérations dans ces classes.",22);
insert into Participant values(0,0,"But","Définit une interface spécifique du domaine qu'utilise le client.");
insert into Participant values(1,0,"Client","Collabore avec les objets en se conformant à l'interface du But.");
insert into Participant values(2,0,"Adapté","Définit une interface existante qui demande adaptation.");
insert into Participant values(3,0,"Adaptateur","Adapte l'interface de l'adapté à l'interface But.");
insert into Participant values(4,1,"Gestionnaire","Définit une interface pour gérer les requêtes. Comporte (éventuellement) le code de liaison avec le successeur.");
insert into Participant values(5,1,"GestionnaireConcret","Gère les requêtes dont il a la charge. Sait accéder à son successeur. Traite la requête s'il le peut, sinon la transmet à son successeur.");
insert into Participant values(6,1,"Adapté","Propose initialement la requête à un objet GestionnaireConcret de la chaîne.");
insert into Participant values(7,2,"Commande","Déclare une interface pour exécuter une opération");
insert into Participant values(8,2,"CommandeConcrète","Définit une astreinte entre un objet récepteur et une action.Concrétise Execute par l'invocation des opérations adéquates du récepteur.");
insert into Participant values(9,2,"Client","Crée un objet CommandeConcrete et positionne son récepteur.");
insert into Participant values(10,2,"Invocateur","Demande à la commande d'entreprendre la requête.");
insert into Participant values(11,2,"Récepteur","Sait comment effectuer les opérations associées avec le traitement d'une requête. Tout type de classe peut servir de récepteur.");
insert into Participant values(12,3,"Composant","Déclare l'interface des objets entrant dans la composition. Implémente le comportement par défaut qui convient pour l'interface commune à toutes les classes. Déclare une interface pour accéder à ses composants enfants et les gérer.Eventuellement, il définit une interface pour accéder à un parent du composant dans une structure récursive, et l'implémente si besoin est.");
insert into Participant values(13,3,"Feuille","Représente des objets feuille dans la composition. Une feuille n'a pas d'enfants. Définit le comportement d'objets primitifs dans la composition.");
insert into Participant values(14,3,"Composite","Définit le comportement des composants dotés d'enfants. Il stocke les composants enfants. Il implémente les opérations liées aux enfants dans l'interface Composant.");
insert into Participant values(15,3,"Client","Manipule les objets de la composition à l'aide de l'interface Composant.");
insert into Participant values(16,4,"Composant","Définit l'interface des objets qui peuvent recevoir dynamiquement des responsabilités supplémentaires.");
insert into Participant values(17,4,"ComposantConcret (ComposantADécorer)","Définit un objet auquel des responsabilités supplémentaires peuvent être adjointes.");
insert into Participant values(18,4,"Décorateur","Gère une référence à un objet Composant et définit une interface conforme à celle du Composant.");
insert into Participant values(19,4,"DécorateurConcret","Ajoute des responsabilités à un composant.");
insert into Participant values(20,5,"Contexte","Définit l'interface intéressant les clients. Gère une instance d'une sous-classe EtatConcret qui définit l'état en cours.");
insert into Participant values(21,5,"Etat","Définit une interface qui encapsule le comportement associé avec un état particulier de Contexte.");
insert into Participant values(22,5,"Sous-classes EtatConcret","Chaque sous-classe implémente un comportement associé avec l'état de contexte.");
insert into Participant values(23,6,"FabriqueAbstraite","Déclare une interface contenant les opérations de création d'objets produits abstraits.");
insert into Participant values(24,6,"FabriqueConcrète","Implémente les opérations de création d'objets produits concrets.");
insert into Participant values(25,6,"ProduitAbstrait","Déclare une interface pour un type d'objet produit.");
insert into Participant values(26,6,"ProduitConcret","Définit un objet produit qui doit être créé par la fabrique concrète correspondante. Implémente l'interface de ProduitAbstrait.");
insert into Participant values(27,6,"Client","N'utilise que les interfaces déclarées par les classes FabriqueAbstraite et ProduitAbstrait.");
insert into Participant values(28,7,"Produit","Définit l'interface des objets créés par la fabrique.");
insert into Participant values(29,7,"ProduitConcret","Implémente l'interface Produit");
insert into Participant values(30,7,"Créateur","Déclare la fabrique ; celle-ci renvoie un objet de type Produit. Le Créateur peut également définir une implémentation par défaut de la fabrique, qui renvoie un objet ProduitConcret par défaut. Peut appeler la fabrique pour créer un objet Produit.");
insert into Participant values(31,7,"CréateurConcret","Surcharge la fabrique pour renvoyer une instance d'un ProduitConcret.");
insert into Participant values(32,8,"Façade","Connaît les classes du sous-système compétentes pour une requête. Délègue le traitement des requêtes clients aux objets appropriés du sous-système.");
insert into Participant values(33,8,"Classes du sous-système","Implémentent les fonctionnalités du sous-système. Gèrent les travaux assignés par l'objet Façade. Ne connaissent pas la façade ; c'est-à-dire qu'elles n'ont pas de références à celle-ci.");
insert into Participant values(34,9,"ExpressionAbstraite","Déclare une opération Interprete abstraite commune à tous les noeuds de l'arbre syntaxique abstrait.");
insert into Participant values(35,9,"ExpressionTerminale","Implémente une opération interprète associée, dans la grammaire, à des symboles terminaux. Chaque symbole terminal de la phrase demande une instance de cette classe.");
insert into Participant values(36,9,"ExpressionNonTerminale","Requise pour chaque règle R : := RI R2 ... Rn , de la grammaire. Gère des variables d'instance du type ExpressionAbstraite, pour chacun des symboles R1 à Rn. Implémente une opération Interprete pour les symboles non termi¬naux de la grammaire. C'est une caractéristique de cette opération de s'appeler récursivement sur les variables représentant R1 à Rn.");
insert into Participant values(37,9,"Contexte","Contient une information à caractère global pour l'interprète.");
insert into Participant values(38,9,"Client","Construit (ou reçoit) un arbre syntaxique abstrait représentant une phrase particulière dans le langage défini par sa grammaire. L'arbre syntaxique abstrait est constitué d'instances des classes ExpressionNonTerminale et ExpressionsTerminale. Invoque l'opération Interprete.");
insert into Participant values(39,10,"Itérateur","Définit un interface pour accéder aux éléments et les parcourir.");
insert into Participant values(40,10,"ItérateurConcret","Implémente l'interface Iterateur. Assure le suivi de l'élément courant lors de la traversée d'un agrégat.");
insert into Participant values(41,10,"Liste","Définit une interface pour la création d'un objet Iterateur.");
insert into Participant values(42,10,"ListeConcrète","Implémente l'interface de création de Iterateur, afin de retourner l'instance adéquate de IterateurConcret.");
insert into Participant values(43,11,"Médiateur","Définit une interface pour communiquer avec les objets collègues");
insert into Participant values(44,11,"MédiateurConcret","Réalise le comportement coopératif en coordonnant les objets Collegue. Connaît et gère ses collègues.");
insert into Participant values(45,11,"Classes collègues","Chaque classe Collegue connaît son objet Mediateur. Chaque collègue s'adresse à son médiateur chaque fois, alors qu'autrement, il aurait communiqué directement avec un autre collègue.");
insert into Participant values(46,12,"Mémento","Mémorise l'état interne de l'objet original. Il peut stocker autant d'informations d'état interne de l'original que nécessaire, à la discrétion de ce dernier. Protège des incursions d'objets autres que l'auteur. Les mémentos ont effectivement deux interfaces. Le Surveillant voit l'interface étroite du Memento - il ne peut que faire passer le mémento aux autres objets. Au contraire, l'Auteur voit l'interface large, celui qui lui permet d'accéder à toutes les données nécessaires à sa restauration dans l'état antérieur. Théoriquement, seul l'Auteur, producteur du mémento, devrait avoir le droit d'accéder à l'état interne du mémento.");
insert into Participant values(47,12,"Auteur","Crée un objet Memento contenant un instantané de son état interne courant. Utilise Memento pour restaurer son état interne.");
insert into Participant values(48,12,"Surveillant","Est responsable de la sauvegarde de Memento. N'agit jamais sur Memento, ni ne l'examine.");
insert into Participant values(49,13,"Monteur","Spécifie une interface abstraite pour la création de parties d'un objet Produit.");
insert into Participant values(50,13,"MonteurConcret","Construit et assemble des parties du produit par implémentation de l'interface Monteur. Définit la représentation qu'il crée et en conserve la trace. Fournit une interface pour la récupération du produit final.");
insert into Participant values(51,13,"Directeur","Construit un objet en utilisant l'interface de Monteur.");
insert into Participant values(52,13,"Produit","Représente l'objet complexe en cours de construction. MonteurConcret construit la représentation interne du produit et définit le processus par lequel il est assemblé. Comporte les classes qui définissent les parties constitutives, y compris les interfaces nécessaires à l'assemblage des parties pour donner le résultat final.");
insert into Participant values(53,14,"Sujet","Connaît ses observateurs. Un nombre quelconque d'observateurs peut observer un sujet. Fournit une interface pour attacher et détacher les objets observateurs.");
insert into Participant values(54,14,"Observateur","Définit une interface de mise à jour pour les objets qui doivent être notifiés de changements dans un sujet.");
insert into Participant values(55,14,"SujetConcret","Mémorise les états qui intéressent les objets ObservateurConcret. Envoie une notification à ses observateurs lorsqu'il change d'état.");
insert into Participant values(56,14,"ObservateurConcret","Gère une référence sur un objet SujetConcret. Mémorise l'état qui doit rester pertinent pour le sujet. Fait l'implémentation de l'interface de mise à jour de l'Observateur pour conserver la cohérence de son état avec le sujet.");
insert into Participant values(57,15,"ClasseAbstraite","Définit des opérations primitives abstraites que les sous-classes concrètes doivent implémenter. Implémente une méthode patronMethode définissant le squelette d'un algorithme qui fait appel aux méthodes primitives abstraites.");
insert into Participant values(58,15,"ClasseConcrète","Implémente les opérations primitives qui assurent l'exécution de chaque étapes de l'algorithme définit dans la super classe.");
insert into Participant values(59,16,"PoidsMouche","Déclare une interface à travers laquelle les poids mouche peuvent recevoir les états extrinsèques et agir sur eux.");
insert into Participant values(60,16,"PoidsMoucheConcret","Implémente l'interface d'un poids mouche et stocke éventuellement les états intrinsèques. Un objet PoidsMoucheConcret doit être partageable. Tout état qu'il contient doit être intrinsèque ; c'est-à-dire être indépendant du contexte de l'objet.");
insert into Participant values(61,16,"PoidsMoucheConcretNonPartagé","Toutes les sous-classes de PoidsMouche ne sont pas nécessairement partagées. L'interface PoidsMouche permet le partage, il ne l'impose pas. Il est courant pour des objets PoidsMoucheConcretNonPartage d'avoir pour enfants des objets PoidsMoucheConcret à certains niveaux de la structure d'objets PoidsMouche");
insert into Participant values(62,16,"FabriqueDePoidsMouche","Crée et gère des objets PoidsMouche. S'assure que les objets PoidsMouche sont convenablement partagés. Si un client réclame un Poids Mouche, l'objet FabriqueDePoidsMouche fournit une instance existante ou en crée une s'il n'y en a pas.");
insert into Participant values(63,16,"Client","Gère une référence aux Poids Mouche. Calcule ou mémorise l'état extrinsèque des Poids Mouche.");
insert into Participant values(64,17,"Abstraction","Définit l'interface de l'abstraction, Gère une référence à un objet de type Implementeur.");
insert into Participant values(65,17,"AbstractionFine","Spécialise l'interface définie par l'abstraction.");
insert into Participant values(66,17,"Implémenteur","Définit l'interface des classes d'implémentation. Cette interface ne doit pas nécessairement correspondre exactement à l'inter¬face d'abstraction ; en fait, les deux interfaces peuvent être très différentes. En général, l'interface de l'implémenteur fournit uniquement des opérations primitives, et l'abstraction, des opérations de plus haut niveau, fondées sur ces primitives.");
insert into Participant values(67,17,"ImplémenteurConcret","Implémente l'interface de l'implémenteur et réalise concrètement son implémentation.");
insert into Participant values(69,18,"Procuration","Gère une référence qui lui permet d'accéder au sujet réel. Une procuration peut faire référence à un Sujet, si les interfaces de SujetReel et de Sujet sont les mêmes. Procure une interface identique à celle du Sujet, de sorte que la procuration puisse être substituée au sujet réel. Contrôle l'accès au sujet réel, et peut être responsable de la création et de la suppression de ce dernier. Encode une requête et ses arguments, puis envoie cette requête ainsi encodée au sujet réel, dans un autre espace d'adresses. Peut détenir des informations supplémentaires concernant le sujet réel, de façon à pouvoir différer le moment d'y accéder. Vérifie que l'appelant a les permissions d'accès requises pour effectuer une requête.");
insert into Participant values(70,18,"Sujet","Définit une interface commune pour SujetReel et procuration, de sorte que procuration puisse être utilisée partout ou SujetReel est attendu.");
insert into Participant values(71,18,"SujetRéel","Définit l'objet réel représenté par la procuration.");
insert into Participant values(72,19,"Prototype","Déclare une interface pour se cloner lui-même.");
insert into Participant values(73,19,"PrototypeConcret","Implémente une opération capable de se cloner elle-même.");
insert into Participant values(74,19,"Client","Crée un nouvel objet en demandant à un prototype de se cloner.");
insert into Participant values(75,20,"Singleton","Définit une opération Instance qui donne au client l'accès à son unique instance. Instance est une opération de classe (c'est-à-dire, une méthode de classe en Smalltalk, et une fonction membre statique en C++). Il peut avoir la charge de créer sa propre instance unique.");
insert into Participant values(76,21,"Stratégie","Déclare une interface commune à tous les algorithmes représentés. Contexte utilise cette interface pour appeler l'algorithme défini par une StrategieConcrete.");
insert into Participant values(77,21,"StratégieConcrète","Implémente l'algorithme, en utilisant l'interface Stratégie.");
insert into Participant values(78,21,"Contexte","Est composé à l'aide d'un objet StrategieConcrete. Gère une référence à un objet Stratégie. Peut définir une interface qui permette à Stratégie d'accéder à ses données.");
insert into Participant values(79,22,"Visiteur","Déclare une opération Visite pour chaque classe ElementConcret de la structure d'objets. Le nom de l'opération et sa signature identifient la classe émettrice de la requête Visite vers le visiteur. Cela permet au visiteur de déterminer la classe concrète de l'élément visité. Le visiteur peut ensuite accéder à l'élément directement, au travers de son interface particulière.");
insert into Participant values(80,22,"VisiteurConcret","Concrétise par codage chaque opération déclarée par la classe Visiteur. Chaque opération code un fragment de l'algorithme défini pour les classes d'objets qui lui correspondent dans la structure. Le visiteur concret fournit le contexte pour l'algorithme et mémorise son état local. Cet état représente souvent le cumul des résultats obtenus pendant le parcours de la structure.");
insert into Participant values(81,22,"Element","Définit une opération Accepte qui prend pour argument un visiteur.");
insert into Participant values(82,22,"ElementConcret","Réalise le codage d'une opération Accepte qui prend pour argument un visiteur.");
insert into Participant values(83,22,"StructureDObjets","Peut énumérer ses éléments. Peut fournir une interface de haut niveau permettant au visiteur de visiter ses éléments. Peut être un composite ou un conteneur tel qu'une liste ou un ensemble.");
insert into Key_point values(0,"Extensibilité",1);
insert into Content_Key_Point values(0,0,"Factorisation du chaînage entre objets");
insert into Content_Key_Point values(1,0,"Point d'accès unique pour le client");
insert into Content_Key_Point values(2,0,"L'ajout ou la suppression d'un nouveau élément dans la chaîne ne nécessite pas de modification de code");
insert into Key_point values(1,"Extensibilité",2);
insert into Content_Key_Point values(3,1,"L'ajout ou la suppression d'une commande ne nécessite pas de modification de code");
insert into Content_Key_Point values(4,1,"Factorisation du protocole des commandes");
insert into Key_point values(2,"Protocole uniforme",2);
insert into Content_Key_Point values(5,2,"Point d'accès unique pour l'exécution des commandes");
insert into Key_point values(3,"Historisation simplifiée",2);
insert into Content_Key_Point values(6,3,"Historisation des commandes facilité");
insert into Key_point values(4,"Découplage et extensibilité",3);
insert into Content_Key_Point values(7,4,"Factorisation maximale de la composition");
insert into Content_Key_Point values(8,4,"L'ajout ou la suppression d'une feuille n'implique pas de modification de code");
insert into Content_Key_Point values(9,4,"L'ajout ou la suppression d'un composite ne n'implique pas de modification de code");
insert into Key_point values(5,"Protocole uniforme",3);
insert into Content_Key_Point values(10,5,"Protocole uniforme sur les opérations des objets composés");
insert into Content_Key_Point values(11,5,"Protocole uniforme sur la gestion de la composition");
insert into Content_Key_Point values(12,5,"Point d'accès unique pour la classe client");
insert into Key_point values(6,"Extensibilité",4);
insert into Content_Key_Point values(13,6,"L'ajout ou la suppression d'un décorateur n'implique pas de modification de code");
insert into Content_Key_Point values(14,6,"L'ajout ou la suppression d'un objet à décorer n'implique pas de modification de code");
insert into Key_point values(7,"Découplage entre les objets décorateurs et les objets à décorer",4);
insert into Content_Key_Point values(15,7,"Nombre minimal de classes Décorateur");
insert into Content_Key_Point values(16,7,"Factorisation maximale entre les décorateurs et les objets à décorer");
insert into Key_point values(8,"Gestion des décorateurs à l'exécution",4);
insert into Content_Key_Point values(17,8,"Les objets à décorer n'ont aucune connaissance des décorateurs");
insert into Content_Key_Point values(18,8,"Un décorateur peut être décoré par un autre décorateur");
insert into Key_point values(9,"Extensibilité",5);
insert into Content_Key_Point values(19,9,"Factorisation de protocole pour tous les états");
insert into Content_Key_Point values(20,9,"L'ajout ou la suppression d'un état n'implique pas de modification de code");
insert into Key_point values(10,"Gestion simplifiée",5);
insert into Content_Key_Point values(21,10,"Changement d'état possible à l'exécution sans destruction");
insert into Content_Key_Point values(22,10,"Découplage du comportement de chaque état");
insert into Key_point values(11,"Extensibilité",11);
insert into Content_Key_Point values(23,11,"Découplage entre collègues");
insert into Content_Key_Point values(24,11,"Factorisation des protocoles de Médiateurs");
insert into Key_point values(12,"Gestion simplifiée",11);
insert into Content_Key_Point values(25,12,"Protocoles de communication entre les objets simplifiés");
insert into Content_Key_Point values(26,12,"Nombre minimal de messages échangés");
insert into Key_point values(13,"Extensibilité",17);
insert into Content_Key_Point values(27,13,"L'ajout ou la suppression d'un implémenteur concret n'implique pas de modification de code");
insert into Content_Key_Point values(28,13,"L'ajout ou la suppression d'une abstraction fine ne nécessite pas de modification de code");
insert into Key_point values(14,"Découplage entre abstraction et implémenteur",17);
insert into Content_Key_Point values(29,14,"Nombre minimal d'implémenteurs concrets");
insert into Content_Key_Point values(30,14,"Factorisation maximale du lien entre abstraction et implémenteur");